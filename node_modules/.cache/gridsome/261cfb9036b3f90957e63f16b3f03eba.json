{"remainingRequest":"C:\\Users\\Oluwaseun Olowu\\Documents\\Njtd\\njtd_site_new\\node_modules\\babel-loader\\lib\\index.js??ref--1-1!C:\\Users\\Oluwaseun Olowu\\Documents\\Njtd\\njtd_site_new\\node_modules\\gridsome\\app\\fetch.js","dependencies":[{"path":"C:\\Users\\Oluwaseun Olowu\\Documents\\Njtd\\njtd_site_new\\node_modules\\gridsome\\app\\fetch.js","mtime":1725826220810},{"path":"C:\\Users\\Oluwaseun Olowu\\Documents\\Njtd\\njtd_site_new\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1725826210235},{"path":"C:\\Users\\Oluwaseun Olowu\\Documents\\Njtd\\njtd_site_new\\node_modules\\babel-loader\\lib\\index.js","mtime":1725826212301}],"contextDependencies":[],"result":["import \"core-js/modules/es.error.cause.js\";\nimport prefetch from './utils/prefetch';\nimport { unslashEnd } from './utils/helpers';\nimport { NOT_FOUND_PATH } from '~/.temp/constants';\nconst dataUrl = process.env.DATA_URL;\nconst isPrefetched = {};\nconst isLoaded = {};\nexport default ((route, options = {}) => {\n  const {\n    shouldPrefetch = false,\n    force = false\n  } = options;\n\n  if (!process.isStatic) {\n    const {\n      dynamic = false\n    } = route.meta;\n    let path = dynamic ? route.matched[0].path : route.path;\n\n    if (route.name === '*') {\n      path = NOT_FOUND_PATH;\n    }\n\n    return new Promise((resolve, reject) => {\n      const onFail = err => {\n        isLoaded[route.path] = null;\n        reject(err);\n      };\n\n      const onSuccess = res => {\n        isLoaded[route.path] = null;\n        resolve(res);\n      };\n\n      if (force || !isLoaded[route.path]) {\n        isLoaded[route.path] = fetch(process.env.GRAPHQL_ENDPOINT, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            path,\n            dynamic\n          })\n        }).then(res => res.json());\n      }\n\n      isLoaded[route.path].then(res => {\n        if (res.errors) onFail(res.errors[0]);else if (res.code) onSuccess({\n          code: res.code\n        });else onSuccess({\n          data: res.data,\n          context: res.extensions ? res.extensions.context : {}\n        });\n        isLoaded[route.path] = null;\n      }).catch(onFail);\n    });\n  }\n\n  const hashMeta = document.querySelector('meta[name=\"gridsome:hash\"]').getAttribute('content');\n  return new Promise((resolve, reject) => {\n    const usePath = route.name === '*' ? NOT_FOUND_PATH : route.path;\n    const jsonPath = route.meta.dataPath || unslashEnd(usePath) + '/index.json';\n    const absPath = unslashEnd(dataUrl) + jsonPath;\n\n    if (shouldPrefetch && !isLoaded[jsonPath]) {\n      if (!isPrefetched[jsonPath]) {\n        isPrefetched[jsonPath] = prefetch(absPath);\n      }\n\n      return isPrefetched[jsonPath].then(() => resolve()).catch(() => resolve());\n    }\n\n    if (!isLoaded[jsonPath]) {\n      isLoaded[jsonPath] = fetchJSON(absPath);\n    }\n\n    return isLoaded[jsonPath].then(res => {\n      if (res.hash !== hashMeta) {\n        reject(createError(`Hash did not match: json=${res.hash}, document=${hashMeta}`, 'INVALID_HASH'));\n      } else {\n        resolve(res);\n      }\n    }).catch(err => {\n      isLoaded[jsonPath] = null;\n      reject(err);\n    });\n  });\n});\n\nfunction createError(message, code) {\n  const error = new Error(message);\n  error.code = code;\n  return error;\n}\n\nfunction fetchJSON(jsonPath) {\n  return new Promise((resolve, reject) => {\n    const req = new XMLHttpRequest();\n    req.open('GET', jsonPath, true);\n    req.withCredentials = true;\n\n    req.onload = () => {\n      switch (req.status) {\n        case 200:\n          {\n            let results;\n\n            try {\n              results = JSON.parse(req.responseText);\n            } catch (err) {\n              return reject(new Error(`Failed to parse JSON from ${jsonPath}. ${err.message}.`));\n            }\n\n            if (!results.hash) {\n              return reject(new Error(`JSON data in ${jsonPath} is missing a hash.`));\n            }\n\n            return resolve(results);\n          }\n\n        case 404:\n          {\n            return reject(createError(req.statusText, req.status));\n          }\n      }\n\n      reject(new Error(`Failed to fetch ${jsonPath}.`));\n    };\n\n    req.onerror = () => {\n      reject(new Error(`Failed to fetch ${jsonPath}.`));\n    };\n\n    req.send(null);\n  });\n}",null]}